def solution(n, times):
    answer = float('inf')
    officers = len(times)

    lt = 0
    rt = sum(map(lambda x: x*(n//officers), times))

    while lt < rt:
        mid = (lt + rt) // 2    # 주어진 시간
        passed = 0
        for time in times:
            passed += mid // time   # 각 심사관마다 심사할 수 있는 사람 수
        if passed >= n:
            if answer > mid:
                answer = mid
            rt = mid
        else:
            lt = mid + 1
    return answer


if __name__ == "__main__":
    print(solution(6, [7, 10]), 28)


"""
왜 이 문제가 이분탐색인가?

우선 구하고자 하는 값이 모든 사람이 심사를 받을 수 있는 시간의 최솟값이다.
심사에 걸리는 시간, 남은 사람(n)의 최대 범위가 1,000,000,000까지 된다.

시간이 주어지면 각 심사관마다 심사할 수 있는 사람의 수를 구할 수 있다.
해당 시간에 심사할 수 있는 사람의 합(passed)이 주어진 n값(심사 받아야하는 사람의 수)보다 크면 답이 될 수 있다.

시간을 0분(주어진 시간의 단위는 분이다)부터 1분씩 늘려나가면 언젠가 심사가능 한 사람의 수가 n값보다 커진다.
따라서 답은 0과 무한히 큰 수 사이에 있을 것이다. 
하지만 위와 같은 방법은 만약 답이 1,000,000,000분이라면 1,000,000,000번 계산해야하므로 효율적이지 못하다.
효율적인 방법 중 하나가 이분탐색이다.

최소 시간(0)과 최대 시간의 중간값을 구해 조건을 만족하면 더 작은 값(시간의 최솟값을 구하라고 하였으므로)을 찾고
조건을 만족하지 못한다면 더 큰 값을 찾는다.

이 문제에서 최대 시간은 주어진 인원을 심사관이 똑같이 나눠 심사했을 때라고 가정하고 풀었다.

최대 시간 = (남은 인원 수 // 심사관 수) * (각 심사관마다 소요 시간)

조건을 만족한다면 최솟값을 중간값으로 치환해 다시 중간값을 구하고
조건을 만족하지 못한다면 최댓값을 중간값으로 치환해 다시 중간값을 구한다.
최솟값이 최댓값보다 커질 때까지 반복한다.
0 ------------------------------------- 25 ---------------------------------------------------------- 51
                                        25 -------------------------------- 38 ---------------------- 51
                                        25 ----------------- 31 ----------- 38
                                        25 ----- 28 -------- 31
                                                 28 -- 29 -- 31
                                                 28
"""